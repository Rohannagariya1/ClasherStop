"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerInterceptorNest = void 0;
const rxjs_1 = require("rxjs");
const os = require('os');
const operators_1 = require("rxjs/operators");
const ContextStorage_1 = require("./ContextStorage");
const GroMoLogger_1 = __importDefault(require("../logger/GroMoLogger"));
const MetaDataHelper_1 = require("./MetaDataHelper");
class LoggerInterceptorNest {
    intercept(context, next) {
        var _a;
        const start = Date.now();
        const httpContext = context.switchToHttp();
        const request = httpContext.getRequest();
        const response = httpContext.getResponse();
        const traceId = request.headers['trace-id'] || MetaDataHelper_1.metaDataHelper.generateTraceId();
        request.headers['trace-id'] = traceId; //  review this change , Im updating the trace id in the header of the request 
        const requesterIP = ((_a = request.ip) === null || _a === void 0 ? void 0 : _a.toString()) || ''; // Assuming this gets the client IP. For real client IP behind proxy, use request.headers['x-forwarded-for'] || request.ip
        const uriPath = request.url;
        const method = request.method; // HTTP method (GET, POST, PUT, DELETE)
        const networkInterfaces = os.networkInterfaces();
        const extractedIPs = MetaDataHelper_1.metaDataHelper.extractIP(networkInterfaces);
        const IPAddress = JSON.stringify(extractedIPs);
        return new rxjs_1.Observable(observer => {
            ContextStorage_1.asyncLocalStorage.run({ traceId, IPAddress, requesterIP, uriPath, method }, () => {
                next.handle().pipe((0, operators_1.tap)(() => {
                    // Only log successful responses here, if error is not thrown
                    const statusCode = response.statusCode;
                    GroMoLogger_1.default.http(`[${method}] ${uriPath} - ${Date.now() - start}ms - IP: ${requesterIP} - responseCode: ${statusCode}`);
                }), (0, operators_1.catchError)((error) => {
                    // Handle and log errors
                    const statusCode = error.status; // Use a default if no specific status is set
                    GroMoLogger_1.default.http(`[${method}] ${uriPath} - ${Date.now() - start}ms - IP: ${requesterIP} - responseCode: ${statusCode} - Error: ${error.message}`);
                    return (0, rxjs_1.throwError)(error); // Rethrow the error for further handling
                }), (0, operators_1.finalize)(() => {
                    // Any cleanup can go here
                    if (!observer.closed) {
                        observer.complete();
                    }
                })).subscribe(response => observer.next(response), error => observer.error(error), () => observer.complete());
            });
        });
    }
}
exports.LoggerInterceptorNest = LoggerInterceptorNest;
