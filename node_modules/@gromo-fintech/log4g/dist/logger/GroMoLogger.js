"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const winston_1 = require("winston");
const ErrorStackParser_1 = require("../error-stack-parser/ErrorStackParser");
const TransporterFactory_1 = require("../transport-config/TransporterFactory");
const TransporterType_enum_1 = require("../transport-config/enums/TransporterType.enum");
const ErrorHelper_1 = require("../error-stack-parser/ErrorHelper");
const LogLevel_enum_1 = require("./enums/LogLevel.enum");
const ContextStorage_1 = require("../interceptors/ContextStorage");
const InputHandler_1 = require("./InputHandler");
class GroMoLogger {
    constructor() {
        this.projectName = '';
        this.logger = undefined;
        this.isLoggingDisabled = false;
        this.errorStackParser = new ErrorStackParser_1.ErrorStackParser();
        this.errorStackHelper = new ErrorHelper_1.ErrorHelper();
        this.inputHandler = new InputHandler_1.InputHandler();
    }
    setConfig(options) {
        this.projectName = options.nameOfProject;
        if (!this.projectName) {
            throw new Error('Project name is required');
        }
        if (!options.transporterType) {
            options.transporterType = TransporterType_enum_1.TransporterType.SINGLE_FILE;
        }
        const transportConfiguratorFactory = new TransporterFactory_1.TransportConfiguratorFactory();
        const transportConfigurator = transportConfiguratorFactory.generate(options.transporterType);
        const transportList = transportConfigurator.configureTransports(options);
        this.isLoggingDisabled = transportList.length === 0;
        let logLevel = options.logLevel;
        this.logger = this.initializeLogger(transportList, logLevel);
        if (options.overrideConsole !== false) {
            this.overrideConsole();
        }
    }
    initializeLogger(transportList, logLevel = LogLevel_enum_1.LogLevel.INFO) {
        return (0, winston_1.createLogger)({
            level: logLevel,
            transports: transportList,
        });
    }
    overrideConsole() {
        console.log = (...args) => this.info(...args);
        console.error = (...args) => this.error(...args);
        console.warn = (...args) => this.warn(...args);
        console.debug = (...args) => this.debug(...args);
    }
    warn(...args) {
        let { message, context, id, error } = this.inputHandler.processArgs(args);
        if (!error) {
            error = this.errorStackHelper.getStackTrace();
        }
        this.logMessage('warn', message, error, context, id);
    }
    info(...args) {
        let { message, context, id, error } = this.inputHandler.processArgs(args);
        if (!error) {
            error = this.errorStackHelper.getStackTrace();
        }
        this.logMessage('info', message, error, context, id);
    }
    error(...args) {
        let { message, context, id, error } = this.inputHandler.processArgs(args);
        if (!error) {
            error = this.errorStackHelper.getStackTrace();
        }
        this.logMessage('error', message, error, context, id);
    }
    http(...args) {
        let { message, context, id, error } = this.inputHandler.processArgs(args);
        if (!error) {
            error = this.errorStackHelper.getStackTrace();
        }
        this.logMessage('http', message, error, context, id);
    }
    verbose(...args) {
        let { message, context, id, error } = this.inputHandler.processArgs(args);
        if (!error) {
            error = this.errorStackHelper.getStackTrace();
        }
        this.logMessage('verbose', message, error, context, id);
    }
    debug(...args) {
        let { message, context, id, error } = this.inputHandler.processArgs(args);
        if (!error) {
            error = this.errorStackHelper.getStackTrace();
        }
        this.logMessage('debug', message, error, context, id);
    }
    logMessage(level, message, error, context, id) {
        var _a;
        if (this.isLoggingDisabled)
            return;
        const logContext = ContextStorage_1.asyncLocalStorage.getStore();
        if (this.isLoggingDisabled)
            return;
        const logData = { context };
        logData.traceId = logContext === null || logContext === void 0 ? void 0 : logContext.traceId;
        logData.IPAddress = logContext === null || logContext === void 0 ? void 0 : logContext.IPAddress;
        let logMessage;
        logMessage = message;
        if (error) {
            if (error.message) {
                logMessage += ` - Error: ${error.message}`;
                if (error.stack) {
                    const parsedStack = (_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\n');
                    let formattedStackTrace = '';
                    // Iterate over each line of the stack trace array
                    for (const line of parsedStack) {
                        // Append each line to the formatted stack trace string, but only if it contains an address
                        formattedStackTrace += line + '\n';
                    }
                    if (formattedStackTrace) {
                        logData.parsedStack = formattedStackTrace;
                    }
                }
            }
            else if (error.stack) {
                logData.parsedStack = this.errorStackParser.parse(error.stack, this.projectName);
            }
        }
        if (id)
            logData.id = id;
        if (this.logger)
            this.logger.log(level, logMessage, logData);
    }
    getLoggerForTest() {
        return this.logger;
    }
}
const logger = new GroMoLogger();
exports.default = logger;
